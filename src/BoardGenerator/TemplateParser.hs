module BoardGenerator.TemplateParser ( ) where

import Text.ParserCombinators.Parsec
import BoggleSolver.WordFinder as WF
import Char as C
import System.Random

--  -- 
--  -- Explanation:
--  -- letters are themselves
--  -- the underscore character means a hole
--  -- the * character means a letter to be generated by the template-to-board-generator
--  -- after each spot there may be a multiplier in parentheses
--  -- or a 'freeze-in-unit-times' in square-brackets  
--  a    d    e    e     k
--  u    _    e    e     _
--  e    g    u    x     e
--  e    s    w    j     e
--  _    _    e    e     i     w    o    e     i    e
--  e    i    w    n     e     q    j    t
--  l    s    o    *     n     t    e    k
--  i    e    t    o     i     e    o    o     a    i    e    o     i
--  u    e    h    *     *     i    e    t[2]  o    a    s    i     e
--  t    n    r    c     e(3)  o    c    e     c    q    p    o     y
--  i    e    t    o     i     e    _    _     a    i    e    o     i
--  u    e    h(2) *     *(6)  i    _    _     o    a    s    i     e
--  t    n    r    c     e     o    c    e     c    q    p    o     y


-- The end of line character is \n
eol :: GenParser Char st Char
eol = char '\n'

gameParser :: CharParser () [[WNode]]
gameParser = sepBy dslLine eol

dslLine :: CharParser () [WNode]
dslLine = sepBy nodeP (char ' ')

mult  = between (char '(') (char ')')

nodeP = 
    do
      c <- string "*" <|> string "_" <|> many1 (oneOf (['a'..'z']++['A'..'Z']))
      m <- optionMaybe (mult digit) 
      case m of 
        Just tipl ->
            return WNode { contents    = c, multiplier = C.digitToInt tipl}
        Nothing ->
            return WNode { contents    = c }
  

-- takes a string that represents a template for a board based on the language described
-- at the top of this file, and creates an multidimensional array (list) of WNodes
-- which may be used to actually solve the board later
parseGameDSL :: [Char] -> Either ParseError [[WNode]]
parseGameDSL input = parse gameParser "(unknown)" input


-- addDims takes a 2-dimensional list of WNodes that do not yet have their identity assigned,
-- and adds their identity based upon their place in the mulitdimensional array... indices
-- are 1-based
-- afterwards, since the implict dimensions of where WNodes has been captured implicily in 
-- the ident field of the WNode record, we flatten the list to be one-dimensional
addDims :: [[WNode]] -> [WNode]
addDims nodes = concat withIdents  -- flattens a dimension
        where
          withIdents = map (\(x,r) -> zipWith (\v c-> v{ident=(c,r)}) x [1..]) $ zip nodes [1..]

-- get rid of those nodes that have the "_" underscore character, as this is meant to represent
-- a hole in the board
removeEmptyNodes :: [WNode] -> [WNode]
removeEmptyNodes = filter (\node -> "_" /= contents node)


-- takes a normal WNode and gives it a random character as its contents 
-- if there is an asteriks in the contents field
genRandChar :: WNode -> IO WNode
genRandChar node@WNode{ contents=c } = do
    r <- randomRIO ('a', 'z') 
    case c of 
      "*" ->
          return node{ contents = r:[]}
      _ ->
          return node{ contents = c}

allOfIt inDSL =  do
  case parseGameDSL inDSL of 
    Left err ->
        return (Left err)
    Right result ->
        do 
          nodes <- sequence allnodes
          let rels = concat $ generate nodes
          t <- trie
          let wordsB = wordsOnBoard t (nodes,rels)
          -- mapM putStrLn wordsB
          -- mapM (putStrLn . show) nodes
          return (Right (nodes, wordsB))
      where allnodes = ((map genRandChar) . removeEmptyNodes . addDims) result

                       


-- oo = do 
--   r <- System.Random.randomRIO (97,122)
--   return r


-- e  *     *     * 
-- a  d     *(2)  * 
-- *  l     b     * 
-- *  *(3)  *     * 
