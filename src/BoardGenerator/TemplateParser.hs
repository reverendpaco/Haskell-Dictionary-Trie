module BoardGenerator.TemplateParser  where

import Text.ParserCombinators.Parsec
import BoggleSolver.WordFinder as WF
import Char as C
import System.Random


--  -- 
--  -- Explanation:
--  -- letters are themselves
--  -- the underscore character means a hole
--  -- the * character means a letter to be generated by the template-to-board-generator
--  -- after each spot there may be a multiplier in parentheses
--  -- or a 'freeze-in-unit-times' in square-brackets  
--  a    d    e    e     k
--  u    _    e    e     _
--  e    g    u    x     e
--  e    s    w    j     e
--  _    _    e    e     i     w    o    e     i    e
--  e    i    w    n     e     q    j    t
--  l    s    o    *     n     t    e    k
--  i    e    t    o     i     e    o    o     a    i    e    o     i
--  u    e    h    *     *     i    e    t[2]  o    a    s    i     e
--  t    n    r    c     e(3)  o    c    e     c    q    p    o     y
--  i    e    t    o     i     e    _    _     a    i    e    o     i
--  u    e    h(2) *     *(6)  i    _    _     o    a    s    i     e
--  t    n    r    c     e     o    c    e     c    q    p    o     y


gameParser :: CharParser () [[WNode]]
gameParser = sepBy dslLine eol

simpleSpaces = (many (char ' '))

newlines = (many1 newline)
eol =  try newlines <|> do {newlines;simpleSpaces;newlines}

dslLine :: CharParser () [WNode]
dslLine = many (do {simpleSpaces; r <- nodeP; simpleSpaces; return r})

mult  = between (char '(') (char ')')

nodeP = 
    do
      c <- string "*" <|> string "_" <|> many1 (oneOf (['a'..'z']++['A'..'Z']))
      m <- optionMaybe (mult digit) 
      case m of 
        Just tipl ->
            return WNode { contents    = c, multiplier = C.digitToInt tipl}
        Nothing ->
            return WNode { contents    = c }
  

-- takes a string that represents a template for a board based on the language described
-- at the top of this file, and creates an multidimensional array (list) of WNodes
-- which may be used to actually solve the board later
parseGameDSL :: [Char] -> Either ParseError [[WNode]]
parseGameDSL input = parse gameParser "(unknown)" input


-- addDims takes a 2-dimensional list of WNodes that do not yet have their identity assigned,
-- and adds their identity based upon their place in the mulitdimensional array... indices
-- are 1-based
-- afterwards, since the implict dimensions of where WNodes has been captured implicily in 
-- the ident field of the WNode record, we flatten the list to be one-dimensional
addDims :: [[WNode]] -> [WNode]
addDims nodes = concat withIdents  -- flattens a dimension
        where
          withIdents = map (\(x,r) -> zipWith (\v c-> v{ident=(c,r)}) x [1..]) $ zip nodes [1..]

-- get rid of those nodes that have the "_" underscore character, as this is meant to represent
-- a hole in the board
removeEmptyNodes :: [WNode] -> [WNode]
removeEmptyNodes = filter (\node -> "_" /= contents node)


-- takes a normal WNode and gives it a random character as its contents 
-- if there is an asteriks in the contents field
genRandChar :: WNode -> IO WNode
genRandChar node@WNode{ contents=c } = do
    r <- randomRIO ('a', 'z') 
    case c of 
      "*" ->
          return node{ contents = r:[]}
      _ ->
          return node{ contents = c}

allOfIt inDSL =  do
  case parseGameDSL inDSL of 
    Left err ->
        return (Left err)
    Right result ->
        do 
          nodes <- sequence allnodes
          let rels = concat $ generate nodes
          t <- trie
          let wordsB = wordsOnBoard t (nodes,rels)
          mapM putStrLn wordsB
          -- mapM (putStrLn . show) nodes
          return (Right (nodes, wordsB))
      where allnodes = ((map genRandChar) . removeEmptyNodes . addDims) result


runTests = mapM runTest ["c o w\no w l\nd o g",
                         " c o w   \no w l\nd o g",
                         " c o w   \no w l\nd o g\n",
                         " c o w   \no w l\nd o g\n\n\n",
                         " c o w\no w l\nd o g",
                         " c   o  w\no w l\nd o g",
                         "\n c o w   \no w l\nd o g\n\n\n",
                         "\n c o w   \n\n\no w l\nd o g\n\n\n",
                         "\n c o w   \n\n\no  w  l   \n d    o  g   \n\n\n",
                         "\n c o w   \n\n  \no  w  l   \n d    o  g   \n\n\n"
                        ]
runTest testCase = do
    result <- allOfIt testCase
    case result of 
      Left err ->
          do 
            putStrLn "Test Failure"
            putStrLn (show err)
      Right (_,words) -> do
          -- mapM putStrLn words
          putStrLn (show (words == corVal))
        where corVal = ["cow","cowl","coo","cow","cowl","col","colog","coo","cool","cow","cowl","cod","coo","cool","ow","owl","oo","ow","owl","wo","woo","wood","wow","oo","ow","owl","od","oo","wo","wow","woo","wood","wo","woo","wool","woo","wool","wood","wo","woo","wood","wog","lo","loco","low","loo","low","lo","loo","low","lod","log","logwood","do","doc","doco","doo","dool","dow","dowl","doo","dool","do","doo","dow","dowl","dol","dog","oo","ow","owl","od","glow","glow","glow","go","goo","good","gowl","gowd","god"]



-- oo = do 
--   r <- System.Random.randomRIO (97,122)
--   return r


-- e  *     *     * 
-- a  d     *(2)  * 
-- *  l     b     * 
-- *  *(3)  *     * 
